package org.example;

/**
 * Реализует нисходящий синтаксический анализатор LL(1) с рекурсивным спуском.
 * Каждый нетерминал - это функция, которая проверяет подходящий продукт.
 * Если правило содержит другой нетерминал, вызывается соответствующая функция (рекурсивно).
 * Если символ не совпадает - происходит откат (backtracking).
 *
 * <p>Принцип работы:
 * <ul>
 *   <li>Начинаем разбор с нетерминала S (стартовый символ грамматики).</li>
 *   <li>Каждый нетерминал представлен отдельным методом (например, S(), A(), B(), C()).</li>
 *   <li>Если продукция требует терминала, вызывается метод match(), который проверяет текущий символ.</li>
 *   <li>Если текущий символ не соответствует ожидаемому, выполняется откат (backtracking) и пробуется другая продукция.</li>
 *   <li>Если строка полностью разобрана и достигнут символ конца $, строка считается принятой.</li>
 * </ul>
 */

// S’ → S$
// S → CABB
// S → BCA
// A →
// A → aBA
// B → eB
// B → bC
// C → c
// C → d

public class LL1ParserBacktrack {
    private final char INPUT_END = '$';
    private String input;
    private int index;

    /**
     * Стартовый метод для разбора строки.
     * Инициализирует строку для разбора и вызывает основную функцию синтаксического анализа.
     *
     * @param test Строка, которую необходимо разобрать.
     * @return {@code true}, если строка успешно разобрана согласно грамматике, {@code false} в противном случае.
     */
    public boolean parseString(String test) {
        input = test;
        index = 0;
        return parse();
    }

    /**
     * Основной метод синтаксического анализа, начиная с нетерминала S.
     * Вызывает анализатор для нетерминала S и проверяет, что строка заканчивается символом конца ($).
     *
     * @return {@code true}, если строка успешно разобрана, {@code false} в противном случае.
     */
    private boolean parse() {
        return S() && match(INPUT_END);
    }

    /**
     * Метод для разбора нетерминала S.
     * Согласно грамматике, S может быть либо CABB, либо BCA. Пробует оба варианта с откатом.
     *
     * @return {@code true}, если строка соответствует одной из продукций для S, {@code false} в противном случае.
     */
    private boolean S() {
        // В начале каждого метода для нетерминала (например, S(), A(), B())
        // сохраняется текущее значение индекса в переменной backtrack:
        // Это значение индекса соответствует текущей позиции в строке, где начинается анализ для этого метода.
        int backtrack = index;
        if (C() && A() && B() && B()) return true;
        // Если убрать восстановление индекса, то в случае ошибки при CABB индекс останется на месте сбоя.
        // Тогда при разборе BCA парсер начнёт не с начала, а с середины неправильного разбора, что приведёт к некорректным результатам.
        index = backtrack;
        return B() && C() && A();
    }

    /**
     * Метод для разбора нетерминала A.
     * A может быть пустым (ε), либо начинаться с 'a' и продолжаться по правилу aBA.
     *
     * @return {@code true}, если строка соответствует одной из продукций для A, {@code false} в противном случае.
     */
    private boolean A() {
        int backtrack = index;
        if (match('a') && B() && A()) return true;
        index = backtrack;
        return true; // A -> ε
    }

    /**
     * Метод для разбора нетерминала B.
     * B может быть либо eB, либо bC.
     *
     * @return {@code true}, если строка соответствует одной из продукций для B, {@code false} в противном случае.
     */
    private boolean B() {
        int backtrack = index;
        if (match('e') && B()) return true;
        index = backtrack;
        return match('b') && C();
    }

    /**
     * Метод для разбора нетерминала C.
     * C может быть либо символом 'c', либо символом 'd'.
     *
     * @return {@code true}, если строка соответствует одной из продукций для C, {@code false} в противном случае.
     */
    private boolean C() {
        return match('c') || match('d');
    }

    /**
     * Проверяет, соответствует ли текущий символ в строке ожидаемому символу.
     * Если текущий символ совпадает с ожидаемым, индекс строки увеличивается на 1,
     * что позволяет продолжить анализ следующего символа. Если текущий символ не соответствует
     * ожидаемому, метод возвращает {@code false}, не изменяя индекс.
     *
     * <p>Этот метод используется для проверки и продвижения по строке в процессе синтаксического анализа
     * в рамках алгоритма LL(1), который требует точного соответствия терминала с текущим символом входной строки.</p>
     *
     * @param expected Символ, который ожидается на текущей позиции в строке.
     * @return {@code true}, если текущий символ соответствует ожидаемому символу и индекс был
     *         увеличен на 1, {@code false} в случае несоответствия.
     */
    private boolean match(char expected) {
        if (index < input.length() && input.charAt(index) == expected) {
            index++;
            return true;
        }
        return false;
    }
}
