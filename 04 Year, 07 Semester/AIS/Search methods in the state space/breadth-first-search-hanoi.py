from collections import deque
from timeit import default_timer as timer

# Задача «Ханойская башня».
# Есть три стержня, на первом из которых помещены N дисков разного диаметра, причем
# меньший диск обязательно лежит на большем. Требуется переместить все диски на
# третий стержень, двигая их по очереди. Ход в этой головоломке заключается в снятии
# верхнего диска с одного из стержней и перемещении его поверх дисков (если они
# есть) другого стержня. Ограничение заключается в том, что больший диск нельзя класть
# на меньший.

# Представление состояния
class State:
    def __init__(self, pegs):
        self.pegs = pegs

    # Проверка, если состояние конечное (все диски на последнем 3 стержне)
    def is_goal(self, n):
        return len(self.pegs[2]) == n

    def __eq__(self, other):
        return self.pegs == other.pegs

    def __hash__(self):
        # Создаем кортеж, в котором каждый элемент это кортеж представляющий один из стержней
        # Используем кортеж для формирования хэша, так как он неизменяемый и хэшируемый
        # __hash__ необходимо перегрузить для того чтобы использовать обьекты State в set
        return hash(tuple(tuple(peg) for peg in self.pegs))

    # Создает новое состояние, перемещая диск с одного стержня на другой
    def move_disk(self, from_peg, to_peg):
        # Копируем список стержней, создавая новый
        new_pegs = [peg.copy() for peg in self.pegs]
        # К целевому стержню to_peg добавляем верхний диск с from_peg, который представляет диск с которого снимаем диск
        disk = new_pegs[from_peg].pop()
        new_pegs[to_peg].append(disk)
        return State(new_pegs)
    
def print_state(state):
    """Функция для визуализации состояния стержней."""
    for i, peg in enumerate(state.pegs):
        print(f"Стержень {i + 1}: {peg}")
    print()

def bfs_hanoi(n):
    """Выполняет поиск в ширину BFS.

    Алгоритм начинается с заданного источника и исследует все достижимые вершины из этого источника. 
    Мы начинаем с заданного источника и обходим вершины уровень за уровнем, используя структуру данных queue (очередь). 
    Единственная загвоздка заключается в том, что, в отличие от деревьев, 
    графы могут содержать циклы, поэтому мы можем прийти к одной и той же вершине еще раз. 
    Чтобы не обрабатывать вершину более одного раза, используется set visited.

    Args:
        n (int): Количество дисков
        
    Returns:
        int: Минимальное количество ходов, необходимых для перемещения всех дисков на третий стержень. Если решение 
    не найдено, возвращает -1 (хотя для данной задачи решение всегда существует).
    """
    
    # Начальное состояние, список списков
    # Первый список это последовательность от n до 1, где n наибольший диск, 1 наименьший
    # остальные два пустые списка, которые представляют второй и третий стержни, которые вначале пустые
    start = State([list(range(n, 0, -1)), [], []])
    
    # Инициализируем очередь, которая будет представлять очередь состояний ожидающих обработки
    # помещаем start в квадратные скобки так как deque и set могут быть инициализированы только из итерируемых обьектов
    # поэтому создаем список с одним элементом
    # в виде кортежа из start (начального состояния) и 0 (текущий ход)
    # queue = deque([(
    # State1, 0), 
    # (State2, 1), 
    # (State3, 2)
    # ])
    queue = deque([(start, 0)]) # Очередь хранит кортеж (состояние, количество ходов)
    # Создаем set посещенных состояний, это предовратит повторное исследование тех же состояний
    visited = set([start])

    # Количество ходов
    moves = 0

    # Пока очередь не пустая
    while queue:
        # popleft() удаляет и возвращает элемент с левого конца очереди
        # элемент который был добавлен первым, будет извлечен первым (FIFO (First In, First Out))
        # tuple unpacking
        current_state, moves = queue.popleft()
        
        # Проверка, если это целевое состояние
        if current_state.is_goal(n):
            # print_state(current_state)
            return moves

        # Идем по стержням, используется тройка так как всего дано 3 стержня
        # from_peg - стержень откуда перемещаем диск
        # to_peg - стержень куда перемещаем диск
        for from_peg in range(3):
            # current_state.pegs[from_peg] - список дисков на стержне from_peg
            # not current_state.pegs[from_peg] - проверка пустой ли этот список
            if not current_state.pegs[from_peg]:
                # continue пропустит текущую итерацию в цикле
                # Если на стержне from_peg нет дисков, тоесть он пустой
                # тогда пропускаем итерацию, поскольку нет смысла перемещать диски со стрежня
                # где их нет
                continue
            for to_peg in range(3):
                # from_peg != to_peg - это условие гарантирует, что диск перемещается на другой стержень
                # not current_state.pegs[to_peg] - проверяем если стержень to_peg пустой,
                # если он пустой то диск можно на него положить без дополнительных проверок
                # current_state.pegs[from_peg][-1] < current_state.pegs[to_peg][-1] - 
                # проверяем, что диск который мы хотим переместить (верхний диск на стержне from_peg)
                # меньше чем диск на вершине стержня to_peg
                # индекс -1 используется для доступа к последнему элементу списка 
                if from_peg != to_peg and (not current_state.pegs[to_peg] or
                                           current_state.pegs[from_peg][-1] < current_state.pegs[to_peg][-1]):
                    next_state = current_state.move_disk(from_peg, to_peg)
                    if next_state not in visited:
                        visited.add(next_state)
                        queue.append((next_state, moves + 1))

    return -1  # Если решение не найдено

n = 6  # Количество дисков

num_trials = 10_000
total_time = 0
steps_to_solution = -1

for _ in range(num_trials):
    # Начальное состояние, список списков
    # Первый список это последовательность от n до 1, где n наибольший диск, 1 наименьший
    # остальные два пустые списка, которые представляют второй и третий стержни, которые вначале пустые
    start = timer()
    steps_to_solution = bfs_hanoi(n)
    end = timer()
    total_time += (end - start)

average_time_ms = (total_time / num_trials) * 1000
full_time = total_time

print("Поиск в ширину (BFS)")
print(f"Полное время исполнения {num_trials} исполнений: {full_time:.2f} s")
print(f"Среднее время исполнения: {average_time_ms:.2f} ms")
print(f"Минимальное количество ходов для {n} дисков: {steps_to_solution}")
