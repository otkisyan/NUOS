import math

# https://www.youtube.com/watch?v=trKjYdBASyQ
# https://habr.com/ru/articles/329058/

# Функция для отображения игрового поля
def print_board(board):
    for row in board:
        # Разделям столбцы знаком | и разделям каждую строку
        print("|".join(row))
        print("-" * 5)

# Проверка на победу
def check_winner(board, player):
    win_conditions = [
        [board[0][0], board[0][1], board[0][2]],
        [board[1][0], board[1][1], board[1][2]],
        [board[2][0], board[2][1], board[2][2]],
        [board[0][0], board[1][0], board[2][0]],
        [board[0][1], board[1][1], board[2][1]],
        [board[0][2], board[1][2], board[2][2]],
        [board[0][0], board[1][1], board[2][2]],
        [board[2][0], board[1][1], board[0][2]],
    ]
    # Проверяем, есть ли в игровом поле три одинаковых символа 
    # (либо три "X", либо три "O") в одной из строк, колонок или диагоналей.
    return [player, player, player] in win_conditions

# Проверка на ничью
def check_tie(board):
    # Ничья наступает если все клетки заполнены
    # Проходим по каждой строке и проверяем есть ли хотя бы одна пустая клетка
    # Если найдена хотя бы одна пустая клетка (символ " "), значит игра еще не закончена, возвращаем False
    # Если все строки проверены и пустых клеток не осталось, возвращаем True - ничья
    for row in board:
        if " " in row:
            return False
    return True

# Ход игрока
def player_move(board):
    while True:
        move = input("Введите номер клетки (1-9): ")
        if move.isdigit() and 1 <= int(move) <= 9:
            
            # Фукция divmod() принимает два числа (числитель, знаменатель) в качестве аргументов 
            # и возвращает их частное и остаток в виде кортежа.
            row, col = divmod(int(move) - 1, 3)
            if board[row][col] == " ":
                board[row][col] = "X"
                break
            else:
                print("Эта клетка уже занята!")
        else:
            print("Неверный ввод! Введите число от 1 до 9.")


def minimax(board, is_maximizing):
    """Реализует алгоритм Minimax.

    Minimax работает рекурсивно, возвращая оценочный балл для каждого возможного хода.
    Если ход компьютера (максимизирующий игрок), алгоритм пытается максимизировать результат.
    Если ход игрока (минимизирующий игрок), алгоритм минимизирует результат.
    
    Когда максимизатор возвращает наилучшую оценку своего хода, минимизатор на следующем уровне
    использует эту информацию чтобы минимизировать результат.
    Например, если максимизатор возвращает оценки для своих ходов: 1, -1 и 0,
    минимизатор, зная, что максимизатор пытается выбрать наилучший ход, сможет выбрать ход,
    который минимизирует шансы максимизатора на победу (т.е он выберет ход, ведущий к -1)

    Args:
        board (list of list of str)): Текущее состояние игрового поля 3x3.
        is_maximizing (bool): Если True, ходит компьютер (максимизирующий игрок, "O"). 
            Если False, ходит человек (минимизирующий игрок, "X").

    Returns:
        Оценочный балл хода.
        +1: Победа компьютера ("O").
        -1: Победа игрока ("X").
        0: Ничья.
    """
    if check_winner(board, "O"):
        return 1
    if check_winner(board, "X"):
        return -1
    if check_tie(board):
        return 0

    # Если ход компьютера
    if is_maximizing:
        best_score = -math.inf
        for row in range(3):
            for col in range(3):
                if board[row][col] == " ":
                    board[row][col] = "O"
                    score = minimax(board,  False)
                    board[row][col] = " "
                    
                    # max возвращает элемент с наибольшим значением из данных
                    best_score = max(score, best_score)
                    
        # После того как все рекурсивные вызовы для хода игрока "O" завершены,
        # возвращается максимальная оценка среди всех возможных ходов
        # В каждом уровне рекурсии значение best_score передается обратно к предыдущему уровню.
        return best_score
    
    # Если ход игрока
    else:
        best_score = math.inf
        for row in range(3):
            for col in range(3):
                if board[row][col] == " ":
                    board[row][col] = "X"
                    score = minimax(board, True)
                    board[row][col] = " "
                    
                    # min возвращает элемент с наименьшим значением из данных
                    # Выбирается минимальный результат (наихудший для компьютера)
                    best_score = min(score, best_score)

        # Предполагается, что игрок чья очередь ходить,
        # выберет наиболее выгодный ход
        return best_score

# Ход компьютера
def computer_move(board):
    # best_score будет хранить максимальный "оценочный" балл для хода
    # Компьютер максимизирует, поэтому начинаем с минимального возможного значения, 
    # чтобы любой реальный балл был больше.
    best_score = -math.inf
    
    # best_move будет хранить координаты наилучшего хода, который должен сделать компьютер. 
    # Сначала она None, так как мы еще не знаем, какой ход лучше.
    best_move = None
    
    # Перебираем все клетки на поле 3x3
    for row in range(3):
        for col in range(3):
            # Ищем пустую клетку на поле, и делаем туда ход
            # Это временный ход, после оценки хода клетка опять очистится
            if board[row][col] == " ":
                board[row][col] = "O"
                
                # Вызываем функцию minimax, чтобы оценить этот ход.
                # Передаем False так как следующий ход за игроком, который минимизирует
                
                # Функция minimax возвращает минимальный результат, который человек может добиться, в ответ на ход компьютера
                # когда он будет делать свой ход, и этот результат является оценкой хода для компьютера.
                # Компьютер хочет максимизировать свой итоговый результат,
                # поэтому он выбирает тот ход, который приводит
                # к максимальной оценке из тех минимальных которые вернул minimax.
                
                # Вычисление максимального значения игрока происходит по принципу наихудшего случая:
                # для каждого возможного действия игрока мы проверяем все возможные действия других игроков
                # и определяем наихудшую возможную комбинацию действий - ту,
                # которая дает игроку i наименьшее значение.
                # Затем мы определяем, какое действие может предпринять игрок i,
                # чтобы это наименьшее значение было максимально возможным.

                score = minimax(board, False)
                # После оценки хода клетка очищается, чтобы можно было продолжить проверку других возможных ходов.
                board[row][col] = " "
                
                # Если оценка текущего хода лучше, чем предыдущие ходы (то есть score больше, чем best_score), тогда обновляем переменные
                if score > best_score:
                    best_score = score
                    best_move = (row, col)
                    
    # После того как перебрали все возможные ходы и выбрали лучший, делаем окончателлный ход в клетку с координатами best_move
    board[best_move[0]][best_move[1]] = "O"

# Основная функция
def play_game():
    # Создаем список содержащий 3 списка, каждый по три элемента
    board = [[" " for _ in range(3)] for _ in range(3)]
    print("Добро пожаловать в игру 'Крестики-нолики'!")
    
    while True:
        print_board(board)
        
        # Ход игрока
        player_move(board)
        if check_winner(board, "X"):
            print_board(board)
            print("Поздравляем! Вы победили!")
            break
        if check_tie(board):
            print_board(board)
            print("Ничья!")
            break
        
        # Ход компьютера
        computer_move(board)
        if check_winner(board, "O"):
            print_board(board)
            print("Компьютер победил!")
            break
        if check_tie(board):
            print_board(board)
            print("Ничья!")
            break

# Запуск игры
play_game()
