import heapq
from timeit import default_timer as timer

# Задача «Ханойская башня».
# Есть три стержня, на первом из которых помещены N дисков разного диаметра, причем
# меньший диск обязательно лежит на большем. Требуется переместить все диски на
# третий стержень, двигая их по очереди. Ход в этой головоломке заключается в снятии
# верхнего диска с одного из стержней и перемещении его поверх дисков (если они
# есть) другого стержня. Ограничение заключается в том, что больший диск нельзя класть
# на меньший.

class State:
    def __init__(self, pegs):
        self.pegs = pegs

    # Проверка, если состояние конечное (все диски на последнем 3 стержне)
    def is_goal(self, n):
        return len(self.pegs[2]) == n

    def __eq__(self, other):
        return self.pegs == other.pegs

    def __hash__(self):
        # Создаем кортеж, в котором каждый элемент это кортеж представляющий один из стержней
        # Используем кортеж для формирования хэша, так как он неизменяемый и хэшируемый
        # __hash__ необходимо перегрузить для того чтобы использовать обьекты State в set
        return hash(tuple(tuple(peg) for peg in self.pegs))

    # Создает новое состояние, перемещая диск с одного стержня на другой
    def move_disk(self, from_peg, to_peg):
        # Копируем список стержней, создавая новый
        new_pegs = [peg.copy() for peg in self.pegs]
        disk = new_pegs[from_peg].pop()
        # К целевому стержню to_peg добавляем верхний диск с from_peg, который представляет диск с которого снимаем диск
        new_pegs[to_peg].append(disk)
        return State(new_pegs)

    def heuristic(self, n):
        # n - общее количество дисков
        # self.pegs[2] - представляет 3 стержень,
        # целевой стержень на который должны быть перенесены все диски
        # с помощью len() будем вычислять количество дисков которые уже находятся на 3 стержне
        
        # n - len(self.pegs[2]) будет вычислять количество дисков,
        # которые еще не находятся на целевом стержне, если на 3 стержне находятся все диски
        # то эта разница будет равной нулю, что означает что мы достигли цели
        return n - len(self.pegs[2])
    
def print_state(state):
    """Функция для визуализации состояния стержней."""
    for i, peg in enumerate(state.pegs):
        print(f"Стержень {i + 1}: {peg}")
    print()

def best_first_search(initial_state, n):
    """
    Выполняет поиск по первому наилучшему совпадению (Best-First Search) для решения задачи Ханойской башни.

    Использует приоритетную очередь для выбора состояния с наименьшей эвристической оценкой, что позволяет
    наилучшим образом приближаться к цели. Эвристическая функция измеряет количество дисков, которые еще не находятся
    на целевом стержне. 
    Функция также сохраняет уникальные идентификаторы для обеспечения правильного порядка
    при одинаковых значениях эвристики и отслеживания количества шагов до текущего состояния.
    
    В BFS и DFS, когда мы находимся в узле, мы можем рассматривать любой из соседних узлов в качестве следующего. 
    Таким образом, и BFS, и DFS исследуют пути вслепую, не учитывая никакой функции стоимости. 
    Идея поиска по принципу Best-first seasrch заключается в использовании оценочной функции для принятия решения о том, 
    какой из смежных узлов является наиболее перспективным, и последующем исследовании.

    Args:
        initial_state (State): Начальное состояние задачи, представляющее положение дисков на стержнях.
        n (int): Количество дисков, которые необходимо переместить на целевой стержень.

    Returns:
        int: Минимальное количество шагов, необходимых для перемещения всех дисков на третий стержень. Если решение
              не найдено, возвращает -1.
    """
    
    # Используем heapq для приоритетной очереди
    frontier = []
    unique_id = 0  # Уникальный идентификатор для предотвращения сравнения State
    
    # Очередь будет хранить кортеж из: (эвристика, количество шагов, уникальный id,
    # состояние, список из истории действий до текущего состояния)
    heapq.heappush(frontier, (initial_state.heuristic(n), 0, unique_id, initial_state, []))
    # Создаем set посещенных состояний, это предовратит повторное исследование тех же состояний
    visited = set([initial_state])

    while frontier:
        _, steps, _, current_state, actions = heapq.heappop(frontier)
        
        # Проверка, если это целевое состояние
        if current_state.is_goal(n):
            return steps, actions

        # Идем по стержням, используется тройка так как всего дано 3 стержня
        # from_peg - стержень откуда перемещаем диск
        # to_peg - стержень куда перемещаем диск
        for from_peg in range(3):
            # current_state.pegs[from_peg] - список дисков на стержне from_peg
            # not current_state.pegs[from_peg] - проверка пустой ли этот список
            if not current_state.pegs[from_peg]:
                # continue пропустит текущую итерацию в цикле
                # Если на стержне from_peg нет дисков, тоесть он пустой
                # тогда пропускаем итерацию, поскольку нет смысла перемещать диски со стрежня
                # где их нет
                continue
            for to_peg in range(3):
                # from_peg != to_peg - это условие гарантирует, что диск перемещается на другой стержень
                # not current_state.pegs[to_peg] - проверяем если стержень to_peg пустой,
                # если он пустой то диск можно на него положить без дополнительных проверок
                # current_state.pegs[from_peg][-1] < current_state.pegs[to_peg][-1] - 
                # проверяем, что диск который мы хотим переместить (верхний диск на стержне from_peg)
                # меньше чем диск на вершине стержня to_peg 
                # индекс -1 используется для доступа к последнему элементу
                if from_peg != to_peg and (not current_state.pegs[to_peg] or
                                           current_state.pegs[from_peg][-1] < current_state.pegs[to_peg][-1]):
                    # Если диск можно переместить, создаем новое состояние
                    next_state = current_state.move_disk(from_peg, to_peg)
                    if next_state not in visited:
                        # Может быть ситуация когда в очереди будет несколько состояний с одинаковой евристической оценкой
                        # и одинаковым количеством шагов которые были преодолены для достижения этого состояния,
                        # поэтому будем инкрементировать unique_id, чтобы иметь более глобальный идентификатор хода
                        # и предовращать сравнение State в таких ситуациях
                        unique_id += 1
                        visited.add(next_state)
                        # Создаем и добавляем новое действие
                        new_actions = actions + [(from_peg, to_peg)]
                        heapq.heappush(frontier, (next_state.heuristic(n), steps + 1, unique_id, next_state, new_actions))

    return -1, []  # Если решение не найдено

n = 3  # Количество дисков

num_trials = 10_000
total_time = 0
steps_to_solution = -1

for _ in range(num_trials):
    # Начальное состояние, список списков
    # Первый список это последовательность от n до 1, где n наибольший диск, 1 наименьший
    # остальные два пустые списка, которые представляют второй и третий стержни, которые вначале пустые
    initial_state = State([list(range(n, 0, -1)), [], []])
    start = timer()
    steps_to_solution, action_sequence = best_first_search(initial_state, n)
    end = timer()
    total_time += (end - start)
    
average_time_ms = (total_time / num_trials) * 1000
full_time = total_time

print("Поиск по первому наилучшему совпадению (Best-first search)")
print(f"Полное время исполнения {num_trials} исполнений: {full_time:.2f} s")
print(f"Среднее время исполнения: {average_time_ms:.2f} ms")
print(f"Минимальное количество ходов для {n} дисков: {steps_to_solution}")
for action in action_sequence:
    print(f"Переместить диск с стержня {action[0] + 1} на стержень {action[1] + 1}")
