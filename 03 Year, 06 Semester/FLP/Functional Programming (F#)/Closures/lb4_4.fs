let generateNumbersInRange startNum endNum =
    let x = ref (startNum - 1)
    fun () ->
        if !x < endNum then
            x := !x + 1
            !x
        else
            -1 // Маркер окончания последовательности
            
// При вызове функции generateNumbersInRange создаётся переменная x с помощью ref, 
// и ей присваивается начальное значение startNum - 1. 
// Эта переменная x доступна внутри всей области видимости функции generateNumbersInRange.

// Затем создаётся и возвращается анонимная функция (замыкание) с помощью fun() -> .... 
// Это замыкание захватывает переменную x из окружающего контекста.

// Каждый раз, когда вызывается это замыкание (при помощи generator()), 
// оно увеличивает значение переменной x на 1 и возвращает текущее значение. 
// Таким образом, это замыкание имеет доступ к переменной x даже после того, 
// как функция generateNumbersInRange завершает свою работу,
// потому что переменная x была захвачена в замыкание.

// В результате получается функция, которая возвращает последовательные числа 
// в указанном диапазоне, сохраняя внутреннее состояние 
// (текущее значение) между вызовами. 
// Это и есть суть работы замыкания - сохранение состояния функции между её вызовами, 
// благодаря захвату переменных из окружения.

let generator = generateNumbersInRange 1 10
printfn "%d" (generator()) // Вывод: 1
printfn "%d" (generator()) // Вывод: 2
printfn "%d" (generator()) // Вывод: 3
printfn "%d" (generator()) // Вывод: 4
printfn "%d" (generator()) // Вывод: 5
printfn "%d" (generator()) // Вывод: 6
printfn "%d" (generator()) // Вывод: 7
printfn "%d" (generator()) // Вывод: 8
printfn "%d" (generator()) // Вывод: 9
printfn "%d" (generator()) // Вывод: 10
printfn "%d" (generator()) // Вывод: -1
